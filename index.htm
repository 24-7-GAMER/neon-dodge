<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Neon Slip</title>
<style>
  :root{
    --bg: #06070b;
    --bg2: #0c1020;
    --neon: #19f7ff;
    --neon2: #8a5bff;
    --danger: #ff3b7a;
    --text: #d7f9ff;
  }
  *{ box-sizing: border-box; }
  html, body{
    margin:0; padding:0; width:100%; height:100%;
    background: radial-gradient(1200px 800px at 70% -10%, #131a33 0%, var(--bg) 45%, #05050a 100%);
    overflow:hidden; color:var(--text);
    font-family: "Trebuchet MS","Lucida Console","Courier New",monospace;
    letter-spacing: .5px;
  }
  canvas{ display:block; width:100vw; height:100vh; }
  .ui{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    pointer-events:none;
  }
  .panel{
    pointer-events:auto;
    background: linear-gradient(180deg, rgba(15,20,40,.9), rgba(6,10,20,.9));
    border:1px solid rgba(25,247,255,.35);
    box-shadow: 0 0 25px rgba(25,247,255,.2), inset 0 0 30px rgba(138,91,255,.15);
    padding:24px 28px; border-radius:14px; text-align:center; max-width:320px;
    transition: opacity .35s ease, transform .35s ease;
  }
  .panel.enter{
    animation: panelIn .55s ease;
  }
  @keyframes panelIn{
    0%{ opacity:0; transform: translateY(16px) scale(0.96); }
    100%{ opacity:1; transform: translateY(0) scale(1); }
  }
  .title{
    font-size:28px; color:var(--neon); text-transform:uppercase;
    text-shadow: 0 0 12px rgba(25,247,255,.8);
    font-family: "Impact","Haettenschweiler","Arial Black","Franklin Gothic Heavy",sans-serif;
    letter-spacing:2px;
    margin-bottom:8px;
  }
  .neon-title{
    font-size: clamp(26px, 6vw, 44px);
    line-height:1.05;
    color:#19f7ff;
    text-shadow:
      0 0 6px rgba(25,247,255,.8),
      0 0 18px rgba(138,91,255,.8),
      0 0 32px rgba(255,59,122,.6);
    animation: titleGlow 6s ease-in-out infinite;
  }
  @keyframes titleGlow{
    0%{
      color:#19f7ff;
      text-shadow:
        0 0 6px rgba(25,247,255,.85),
        0 0 18px rgba(138,91,255,.6),
        0 0 30px rgba(255,59,122,.4);
    }
    50%{
      color:#8a5bff;
      text-shadow:
        0 0 8px rgba(138,91,255,.9),
        0 0 22px rgba(25,247,255,.7),
        0 0 34px rgba(255,59,122,.55);
    }
    100%{
      color:#19f7ff;
      text-shadow:
        0 0 6px rgba(25,247,255,.85),
        0 0 18px rgba(138,91,255,.6),
        0 0 30px rgba(255,59,122,.4);
    }
  }
  .btn{
    margin-top:16px; display:inline-block; padding:10px 18px;
    border:1px solid rgba(25,247,255,.5);
    background: rgba(25,247,255,.1);
    color:var(--text); border-radius:10px; cursor:pointer;
  }
  .hint{ font-size:12px; opacity:.8; margin-top:8px; }
  .hidden{ opacity:0; transform: translateY(14px) scale(0.98); pointer-events:none; position:absolute; }
  .hud{
    position:fixed; top:0; left:0; right:0; pointer-events:none;
    display:grid; grid-template-columns:1fr auto 1fr; align-items:center;
    padding:12px 14px; gap:10px;
    font-size:12.5px; letter-spacing:1px; text-transform:uppercase;
    text-shadow: 0 0 8px rgba(25,247,255,.45);
    transition: opacity .3s ease;
  }
  .hud-block{
    display:flex; flex-direction:column; gap:3px;
    color:var(--text);
  }
  .hud-left{ align-items:flex-start; }
  .hud-center{ align-items:center; }
  .hud-right{ align-items:flex-end; }
  .hud-label{
    font-size:10px; opacity:.7;
  }
  .hud-value{
    font-size:16px; letter-spacing:1.5px;
    text-shadow: 0 0 12px rgba(25,247,255,.5);
  }
  .meter{
    width:140px; height:7px; border-radius:8px;
    border:1px solid rgba(25,247,255,.35);
    background: rgba(6,12,20,.6);
    overflow:hidden;
    box-shadow: inset 0 0 12px rgba(25,247,255,.1);
  }
  .meter-fill{
    height:100%; transform-origin:left;
    background: linear-gradient(90deg, rgba(25,247,255,.8), rgba(138,91,255,.95), rgba(255,59,122,.9));
    box-shadow: 0 0 10px rgba(25,247,255,.6);
    transform: scaleX(0);
    transition: transform .12s ease, filter .12s ease;
  }
  .hud-sub{
    font-size:11px; opacity:.85;
  }
  .hud-divider{
    width:100%; height:1px; background: linear-gradient(90deg, rgba(25,247,255,0), rgba(25,247,255,.35), rgba(25,247,255,0));
  }
  .audio-toggle{
    margin-top:6px;
    font-size:10px;
    letter-spacing:1px;
    text-transform:uppercase;
    color:var(--neon);
    cursor:pointer;
    pointer-events:auto;
    opacity:.75;
  }
  .audio-toggle:hover{ opacity:1; }
  @media (min-width: 700px){
    .hud{ font-size:13.5px; padding:14px 18px; }
    .hud-value{ font-size:18px; }
    .meter{ width:170px; height:8px; }
  }
  body[data-state="start"] .hud{ opacity:.45; }
  body[data-state="dying"] .hud{ opacity:.2; }
  body[data-state="over"] .hud{ opacity:.7; }
  body[data-danger="1"] .meter-fill{ filter: brightness(1.4); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="hud">
  <div class="hud-block hud-left">
    <div class="hud-label">Score</div>
    <div class="hud-value" id="score">0</div>
    <div class="hud-divider"></div>
  </div>
  <div class="hud-block hud-center">
    <div class="hud-label">Intensity</div>
    <div class="meter"><div id="intensityFill" class="meter-fill"></div></div>
    <div class="hud-sub">x<span id="intensity">1.0</span></div>
  </div>
  <div class="hud-block hud-right">
    <div class="hud-label">Best</div>
    <div class="hud-value" id="best">0</div>
    <div class="hud-divider"></div>
    <div id="audioToggle" class="audio-toggle">Audio On</div>
  </div>
</div>

<div class="ui">
  <div id="startPanel" class="panel">
    <div class="title neon-title">Neon Slip</div>
    <div>Move left/right to slip through the neon gates.</div>
    <div class="hint">Keys: A/D or Arrows. Touch: drag or tap.</div>
    <div class="btn">Tap to Start</div>
  </div>
  <div id="overPanel" class="panel hidden">
    <div class="title">Crashed</div>
    <div>Score: <span id="finalScore">0</span></div>
    <div>Best: <span id="finalBest">0</span></div>
    <div class="btn">Try Again</div>
    <div class="hint">Instant restart keeps the flow.</div>
  </div>
</div>

<audio id="menuMusic" src="menu.mp3" preload="auto" loop></audio>
<audio id="gameMusic" src="game.mp3" preload="auto" loop></audio>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const bestEl = document.getElementById("best");
  const intensityEl = document.getElementById("intensity");
  const intensityFillEl = document.getElementById("intensityFill");
  const startPanel = document.getElementById("startPanel");
  const overPanel = document.getElementById("overPanel");
  const finalScoreEl = document.getElementById("finalScore");
  const finalBestEl = document.getElementById("finalBest");
  const audioToggleEl = document.getElementById("audioToggle");
  const menuMusic = document.getElementById("menuMusic");
  const gameMusic = document.getElementById("gameMusic");

  let w, h, dpr;
  function resize(){
    dpr = Math.max(1, window.devicePixelRatio || 1);
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  const state = {
    mode: "start",
    time: 0,
    score: 0,
    best: +localStorage.getItem("neonBest") || 0,
    shake: 0,
    shakePower: 0,
    lastTime: 0,
    spawnTimer: 0,
    lastPassETA: null,
    lastGapCenter: null,
    loggedParams: false,
    slowMo: 0,
    flash: 0,
    glitch: 0,
    orbTimer: 0,
    lastOrbTime: -999,
    runSeed: 0,
    rng: null,
    runProfile: null,
    uiScore: 0,
    uiBest: 0,
    uiIntensity: 1,
    scorePulse: 0,
    dangerPulse: 0,
    deathTimer: 0,
    freeze: 0,
    zoom: 0,
    audioUnlocked: false,
    audioMuted: false,
    audioFade: null
  };

  const player = {
    x: w * 0.5,
    y: () => h * 0.82,
    r: 10,
    speed: 620,
    accel: 9000,
    friction: 12000,
    vx: 0,
    targetX: null
  };

  const input = { left:false, right:false, activePointer:false };

  const gates = [];
  const particles = [];
  const orbs = [];
  const trail = [];

  /*
    TUNING (make harder/easier):
    - rampSecondsMin/Max: time to reach high intensity (used for pacing styles only).
    - baseSpeedMin/Max, speedGrowthScaleMin/Max, speedGrowthPowerMin/Max, speedGrowthTimeMin/Max: scroll speed growth.
    - intensityScoreScaleMin/Max, intensityResponseMin/Max: intensity multiplier + UI/pattern response.
    - baseGapMin/Max, gapShrinkPerIntensityMin/Max, minGapMin/Max: gap pressure.
    - minPassIntervalMin/Max, maxPassIntervalMin/Max: reaction windows.
    - patternBiasStrengthMin/Max, patternPeriodMin/Max: anti-camping drift/push.
    - orbTelegraphMin/Max, orbSpeedMin/Max, orbMinIntervalMin/Max: dash orbs.
  */
  const TUNING = {
    rampSecondsMin: 30,
    rampSecondsMax: 46,
    baseSpeedMin: 360,
    baseSpeedMax: 440,
    speedGrowthScaleMin: 0.22,
    speedGrowthScaleMax: 0.32,
    speedGrowthPowerMin: 1.7,
    speedGrowthPowerMax: 2.1,
    speedGrowthTimeMin: 12,
    speedGrowthTimeMax: 20,
    intensityScoreScaleMin: 0.06,
    intensityScoreScaleMax: 0.12,
    intensityResponseMin: 0.4,
    intensityResponseMax: 0.6,
    baseGapMin: 150,
    baseGapMax: 175,
    gapShrinkPerIntensityMin: 24,
    gapShrinkPerIntensityMax: 32,
    minGapMin: 62,
    minGapMax: 74,
    minPassIntervalMin: 0.42,
    minPassIntervalMax: 0.54,
    maxPassIntervalMin: 0.7,
    maxPassIntervalMax: 0.9,
    intervalDecay: 0.12,
    intervalMaxDecay: 0.06,
    reachFactor: 0.98,
    patternBiasStrengthMin: 60,
    patternBiasStrengthMax: 140,
    patternPeriodMin: 2.2,
    patternPeriodMax: 4.2,
    jitterHigh: 0.6,
    jitterLow: 0.22,
    orbTelegraphMin: 0.16,
    orbTelegraphMax: 0.24,
    orbSpeedMin: 880,
    orbSpeedMax: 1120,
    orbMinIntervalMin: 1.05,
    orbMinIntervalMax: 1.35,
    orbSafeGateWindow: 0.35,
    orbYBandOffsetMin: 48,
    orbYBandOffsetMax: 70,
    orbRadius: 7,
    nearMissThreshold: 13,
    slowMoTime: 0.09,
    slowMoScale: 0.7,
    deathGlitchTime: 0.35
  };

  /*
    POLISH / JUICE:
    - uiEase: HUD count-up smoothing.
    - pulseTime / pulseScale: HUD pulse on score.
    - bgDriftSpeed / scanlineAlpha / noiseAlpha: background motion.
    - trailLength / trailFade: player trail.
    - nearMissShake / deathShake: camera response.
    - deathFreeze / deathUiDelay / deathZoom: death transition timing.
  */
  const POLISH = {
    uiEase: 0.18,
    pulseTime: 0.18,
    pulseScale: 0.12,
    bgDriftSpeed: 0.035,
    scanlineAlpha: 0.08,
    noiseAlpha: 0.035,
    trailLength: 12,
    trailFade: 0.5,
    nearMissShake: 0.06,
    deathShake: 0.45,
    deathFreeze: 0.12,
    deathUiDelay: 0.35,
    deathZoom: 0.035,
    visualSpeedBoost: 0.55,
    speedLineCount: 26,
    speedLineAlpha: 0.12
  };

  const AUDIO = {
    menuVolume: 0.45,
    gameVolume: 0.65,
    crossfadeMs: 650
  };

  function clamp(value, min, max){
    return Math.min(max, Math.max(min, value));
  }

  function lerp(a, b, t){
    return a + (b - a) * t;
  }

  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function randRange(min, max){
    const r = state.rng ? state.rng() : Math.random();
    return min + (max - min) * r;
  }

  function randPick(list){
    const r = state.rng ? state.rng() : Math.random();
    return list[Math.floor(r * list.length)];
  }

  function generateRunProfile(){
    state.runSeed = (Date.now() ^ (Math.random() * 1e9)) >>> 0;
    state.rng = mulberry32(state.runSeed);
    const rampSeconds = randRange(TUNING.rampSecondsMin, TUNING.rampSecondsMax);
    const baseSpeed = randRange(TUNING.baseSpeedMin, TUNING.baseSpeedMax);
    const speedGrowthScale = randRange(TUNING.speedGrowthScaleMin, TUNING.speedGrowthScaleMax);
    const speedGrowthPower = randRange(TUNING.speedGrowthPowerMin, TUNING.speedGrowthPowerMax);
    const speedGrowthTime = randRange(TUNING.speedGrowthTimeMin, TUNING.speedGrowthTimeMax);
    const intensityScoreScale = randRange(TUNING.intensityScoreScaleMin, TUNING.intensityScoreScaleMax);
    const intensityResponse = randRange(TUNING.intensityResponseMin, TUNING.intensityResponseMax);
    const baseGap = randRange(TUNING.baseGapMin, TUNING.baseGapMax);
    const gapShrinkPerIntensity = randRange(TUNING.gapShrinkPerIntensityMin, TUNING.gapShrinkPerIntensityMax);
    const minGap = randRange(TUNING.minGapMin, TUNING.minGapMax);
    const minPassInterval = randRange(TUNING.minPassIntervalMin, TUNING.minPassIntervalMax);
    const maxPassInterval = randRange(TUNING.maxPassIntervalMin, TUNING.maxPassIntervalMax);
    const patternMode = randPick(["drift", "push", "oscillate"]);
    const patternBiasStrength = randRange(TUNING.patternBiasStrengthMin, TUNING.patternBiasStrengthMax);
    const patternPeriod = randRange(TUNING.patternPeriodMin, TUNING.patternPeriodMax);
    const patternPhase = randRange(0, Math.PI * 2);
    const pacingStyle = randPick(["steady", "swell", "burst"]);
    const orbSpeed = randRange(TUNING.orbSpeedMin, TUNING.orbSpeedMax);
    const orbMinInterval = randRange(TUNING.orbMinIntervalMin, TUNING.orbMinIntervalMax);
    const orbYBandOffset = randRange(TUNING.orbYBandOffsetMin, TUNING.orbYBandOffsetMax);

    state.runProfile = {
      rampSeconds,
      baseSpeed,
      speedGrowthScale,
      speedGrowthPower,
      speedGrowthTime,
      intensityScoreScale,
      intensityResponse,
      baseGap,
      gapShrinkPerIntensity,
      minGap,
      minPassInterval,
      maxPassInterval,
      patternMode,
      patternBiasStrength,
      patternPeriod,
      patternPhase,
      pacingStyle,
      orbSpeed,
      orbMinInterval,
      orbYBandOffset
    };
  }

  function intensity(){
    const p = state.runProfile || {
      baseSpeed: 260,
      speedGrowthScale: 0.16,
      speedGrowthPower: 1.6,
      speedGrowthTime: 22,
      intensityScoreScale: 0.08
    };
    const speed = speedAtTime();
    const scoreFactor = 1 + Math.log1p(state.score / 3000) * p.intensityScoreScale;
    return (speed / p.baseSpeed) * scoreFactor;
  }

  function intensityNorm(){
    const p = state.runProfile || { intensityResponse: 0.5 };
    const mult = Math.max(0, intensity() - 1);
    return 1 - Math.exp(-p.intensityResponse * mult);
  }

  // SPEED GROWTH CONSTANTS: baseSpeedMin/Max, speedGrowthScaleMin/Max,
  // speedGrowthPowerMin/Max, speedGrowthTimeMin/Max.
  function speedAtTime(){
    const p = state.runProfile || {
      baseSpeed: 260,
      speedGrowthScale: 0.16,
      speedGrowthPower: 1.6,
      speedGrowthTime: 22
    };
    const t = Math.max(0, state.time) / p.speedGrowthTime;
    const growth = Math.pow(t, p.speedGrowthPower);
    return p.baseSpeed * (1 + p.speedGrowthScale * growth);
  }

  function resetGame(){
    generateRunProfile();
    state.time = 0;
    state.score = 0;
    gates.length = 0;
    particles.length = 0;
    orbs.length = 0;
    trail.length = 0;
    player.x = w * 0.5;
    player.vx = 0;
    player.targetX = null;
    state.shake = 0;
    state.shakePower = 0;
    state.spawnTimer = 0;
    state.lastPassETA = null;
    state.lastGapCenter = null;
    state.slowMo = 0;
    state.flash = 0;
    state.glitch = 0;
    state.orbTimer = 0.7;
    state.lastOrbTime = -999;
    state.uiScore = 0;
    state.uiBest = state.best;
    state.uiIntensity = 1;
    state.scorePulse = 0;
    state.dangerPulse = 0;
    state.deathTimer = 0;
    state.freeze = 0;
    state.zoom = 0;
    intensityEl.textContent = "1.0";
    intensityFillEl.style.transform = "scaleX(0)";
    spawnGate(-80, true);
  }

  function setMode(mode){
    state.mode = mode;
    document.body.setAttribute("data-state", mode);
    if (mode === "start" || mode === "over"){
      playMenuMusic();
    } else if (mode === "play"){
      playGameMusic();
    }
  }

  function startGame(){
    initAudio();
    unlockAudio();
    resetGame();
    state.flash = 0.06;
    state.zoom = 0.01;
    if (!state.loggedParams){
      const profile = state.runProfile;
      const maxGapShift = player.speed * profile.minPassInterval * TUNING.reachFactor;
      console.log("[NeonSlip] fairness params:", {
        minPassInterval: profile.minPassInterval,
        maxPassInterval: profile.maxPassInterval,
        minGapWidth: profile.minGap,
        maxAllowedGapShift: Math.round(maxGapShift),
        runSeed: state.runSeed,
        patternMode: profile.patternMode,
        pacingStyle: profile.pacingStyle
      });
      state.loggedParams = true;
    }
    const speedNow = speedAtTime();
    const intensityNow = intensity();
    console.log(
      "[NeonSlip] speed now:",
      speedNow.toFixed(2),
      "intensity x",
      intensityNow.toFixed(2),
      "formula:",
      "speed = baseSpeed * (1 + scale * (t/time)^power)"
    );
    setMode("play");
    startPanel.classList.add("hidden");
    startPanel.classList.remove("enter");
    overPanel.classList.add("hidden");
  }

  function gameOver(){
    setMode("over");
    if (state.score > state.best){
      state.best = state.score;
      localStorage.setItem("neonBest", state.best);
    }
    finalScoreEl.textContent = state.score;
    finalBestEl.textContent = state.best;
    scoreEl.textContent = state.score;
    bestEl.textContent = state.best;

    // Monetization hook: show interstitial ad between runs here.
    showInterstitialAd();

    // Leaderboard hook: submit score to server here.
    submitScore(state.score);

    overPanel.classList.remove("hidden");
    overPanel.classList.add("enter");
    setTimeout(() => overPanel.classList.remove("enter"), 600);
  }

  function beginDeath(){
    if (state.mode !== "play") return;
    state.freeze = POLISH.deathFreeze;
    state.deathTimer = POLISH.deathUiDelay;
    state.zoom = POLISH.deathZoom;
    state.glitch = Math.max(state.glitch, TUNING.deathGlitchTime);
    state.flash = Math.max(state.flash, 0.2);
    setMode("dying");
  }

  function patternOffset(){
    const p = state.runProfile;
    if (!p) return 0;
    const intensityN = intensityNorm();
    const phase = (state.time / p.patternPeriod) * Math.PI * 2 + p.patternPhase;
    const strength = p.patternBiasStrength * (0.65 + intensityN * 0.55);
    if (p.patternMode === "push"){
      return strength * (Math.sin(phase) >= 0 ? 1 : -1);
    }
    if (p.patternMode === "oscillate"){
      return strength * Math.sin(phase);
    }
    return strength * Math.sin(phase * 0.65 + Math.sin(phase) * 0.35);
  }

  function chooseGapCenter(gapW, passETA, intensityN){
    const minCenter = 40 + gapW / 2;
    const maxCenter = w - 40 - gapW / 2;
    let center = clamp(w * 0.5 + patternOffset(), minCenter, maxCenter);

    if (state.lastGapCenter != null && state.lastPassETA != null){
      const timeDelta = Math.max(0.05, passETA - state.lastPassETA);
      const maxShift = player.speed * timeDelta * TUNING.reachFactor;
      const bias = 0.55 + intensityN * 0.25;
      const patternCenter = clamp(w * 0.5 + patternOffset(), minCenter, maxCenter);
      const target = lerp(patternCenter, player.x, 0.2);
      const blended = state.lastGapCenter * bias + target * (1 - bias);
      const jitterScale = lerp(TUNING.jitterHigh, TUNING.jitterLow, intensityN);
      const jitter = (randRange(-1, 1)) * maxShift * jitterScale;
      const allowedLeft = state.lastGapCenter - maxShift;
      const allowedRight = state.lastGapCenter + maxShift;
      center = clamp(blended + jitter, allowedLeft, allowedRight);
    }

    return clamp(center, minCenter, maxCenter);
  }

  function spawnGate(yOverride, easy){
    const intensityN = intensityNorm();
    const intensityVal = intensity();
    const p = state.runProfile;
    const gapW = Math.max(p.minGap, p.baseGap - (intensityVal - 1) * p.gapShrinkPerIntensity);
    const y = yOverride != null ? yOverride : -40;
    const playerY = player.y();
    let speed = Math.max(p.baseSpeed, speedAtTime());
    let passETA = state.time + (playerY - y) / speed;

    if (state.lastPassETA != null){
      const intensityMult = intensity();
      const minInterval = p.minPassInterval / (1 + intensityMult * TUNING.intervalDecay);
      const maxInterval = p.maxPassInterval / (1 + intensityMult * TUNING.intervalMaxDecay);
      const minETA = state.lastPassETA + minInterval;
      const maxETA = state.lastPassETA + Math.max(minInterval, maxInterval);
      if (passETA < minETA){
        passETA = minETA;
      } else if (passETA > maxETA){
        passETA = maxETA;
      }
      speed = (playerY - y) / Math.max(0.05, passETA - state.time);
      if (speed < p.baseSpeed) speed = p.baseSpeed;
      passETA = state.time + (playerY - y) / speed;
    }

    const gapCenter = chooseGapCenter(gapW, passETA, intensityN);
    const gapX = gapCenter - gapW / 2;
    gates.push({
      y,
      gapX, gapW, speed, passed:false, passETA
    });
    state.lastPassETA = passETA;
    state.lastGapCenter = gapCenter;
  }

  function updateGates(dt){
    const intensityN = intensityNorm();
    const intensityMult = intensity();
    const p = state.runProfile;
    const minInterval = p.minPassInterval / (1 + intensityMult * TUNING.intervalDecay);
    const maxInterval = p.maxPassInterval / (1 + intensityMult * TUNING.intervalMaxDecay);
    const baseInterval = lerp(maxInterval, minInterval, intensityN);
    let interval = baseInterval;
    if (p.pacingStyle === "swell"){
      interval *= 0.85 + 0.25 * Math.sin(state.time * 0.9 + p.patternPhase);
    } else if (p.pacingStyle === "burst"){
      const cycle = p.patternPeriod * 1.6;
      const phase = (state.time % cycle) / cycle;
      interval *= phase < 0.35 ? 0.78 : 1.05;
    }
    interval = clamp(interval, minInterval, Math.max(minInterval, maxInterval));
    state.spawnTimer = (state.spawnTimer || 0) - dt;
    if (state.spawnTimer <= 0){
      spawnGate();
      state.spawnTimer = interval;
    }

    for (let i = gates.length - 1; i >= 0; i--){
      const g = gates[i];
      g.y += g.speed * dt;

      if (!g.passed && g.y > player.y()){
        g.passed = true;
        const px = player.x;
        const inside = px > g.gapX && px < g.gapX + g.gapW;
        if (!inside){
          sfxCrash();
          state.shake = POLISH.deathShake;
          state.shakePower = 14;
          beginDeath();
          return;
        } else {
          const edgeDist = Math.min(
            Math.abs(px - g.gapX),
            Math.abs(px - (g.gapX + g.gapW))
          );
          const bonus = edgeDist < 18 ? 8 : edgeDist < 35 ? 4 : 2;
          state.score += 10 + bonus;
          state.scorePulse = POLISH.pulseTime;
          sfxPass();
          spawnParticles(px, g.y);
          state.shake = POLISH.nearMissShake;
          state.shakePower = 4;
          if (edgeDist <= TUNING.nearMissThreshold){
            state.slowMo = TUNING.slowMoTime;
            state.flash = 0.12;
            state.dangerPulse = POLISH.pulseTime;
          }
        }
      }

      if (g.y > h + 60) gates.splice(i, 1);
    }
  }

  function getNextGateETA(){
    let eta = null;
    for (const g of gates){
      if (!g.passed){
        if (eta == null || g.passETA < eta) eta = g.passETA;
      }
    }
    return eta;
  }

  function spawnOrb(){
    const now = state.time;
    if (orbs.length > 0) return;
    if (state.lastPassETA != null && now - state.lastPassETA < TUNING.orbSafeGateWindow){
      return;
    }
    const nextGateETA = getNextGateETA();
    if (nextGateETA != null && nextGateETA - now < TUNING.orbSafeGateWindow + TUNING.orbTelegraphMax){
      return;
    }

    const p = state.runProfile;
    const y = clamp(player.y() - p.orbYBandOffset, 80, h - 80);
    const telegraph = lerp(TUNING.orbTelegraphMin, TUNING.orbTelegraphMax, randRange(0, 1));
    let dir = randPick([-1, 1]);
    if (player.x < 90) dir = 1;
    if (player.x > w - 90) dir = -1;
    const startX = dir === 1 ? -40 : w + 40;
    orbs.push({
      x: startX,
      y,
      vx: dir * p.orbSpeed,
      r: TUNING.orbRadius,
      telegraph,
      telegraphLeft: telegraph,
      active: false
    });
    state.lastOrbTime = now;
  }

  function updateOrbs(dt){
    const intensityN = intensityNorm();
    const p = state.runProfile;
    const orbInterval = Math.max(0.85, p.orbMinInterval - intensityN * 0.35);
    state.orbTimer -= dt;
    if (state.orbTimer <= 0){
      spawnOrb();
      state.orbTimer = orbInterval;
    }

    for (let i = orbs.length - 1; i >= 0; i--){
      const o = orbs[i];
      if (o.telegraphLeft > 0){
        o.telegraphLeft -= dt;
        if (o.telegraphLeft <= 0) o.active = true;
      } else {
        o.x += o.vx * dt;
        if (o.x < -80 || o.x > w + 80){
          orbs.splice(i, 1);
          continue;
        }
        const dx = o.x - player.x;
        const dy = o.y - player.y();
        const hit = (dx * dx + dy * dy) <= (o.r + player.r) * (o.r + player.r);
        if (hit){
          sfxCrash();
          state.shake = POLISH.deathShake;
          state.shakePower = 14;
          beginDeath();
          return;
        }
      }
    }
  }

  function updatePlayer(dt){
    const move = (input.right ? 1 : 0) - (input.left ? 1 : 0);
    if (player.targetX != null){
      const dx = player.targetX - player.x;
      const desired = clamp(dx * 8, -player.speed, player.speed);
      const dv = clamp(desired - player.vx, -player.accel * dt, player.accel * dt);
      player.vx += dv;
      player.x += player.vx * dt;
    } else if (move !== 0){
      const desired = move * player.speed;
      const dv = clamp(desired - player.vx, -player.accel * dt, player.accel * dt);
      player.vx += dv;
      player.x += player.vx * dt;
    } else {
      const dv = clamp(-player.vx, -player.friction * dt, player.friction * dt);
      player.vx += dv;
      if (Math.abs(player.vx) < 6) player.vx = 0;
      player.x += player.vx * dt;
    }
    player.x = Math.max(14, Math.min(w - 14, player.x));
  }

  function spawnParticles(x, y){
    for (let i = 0; i < 10; i++){
      particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 160,
        vy: -Math.random() * 120,
        life: 0.5 + Math.random() * 0.3
      });
    }
  }

  function updateParticles(dt){
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 220 * dt;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function updateTrail(dt){
    trail.push({ x: player.x, y: player.y(), life: 1 });
    while (trail.length > POLISH.trailLength) trail.shift();
    for (let i = trail.length - 1; i >= 0; i--){
      trail[i].life -= dt * POLISH.trailFade;
      if (trail[i].life <= 0) trail.splice(i, 1);
    }
  }

  function updateHud(dt){
    state.uiScore += (state.score - state.uiScore) * POLISH.uiEase;
    state.uiBest += (state.best - state.uiBest) * POLISH.uiEase;
    state.uiIntensity += (intensity() - state.uiIntensity) * POLISH.uiEase;

    if (state.scorePulse > 0) state.scorePulse -= dt;
    if (state.dangerPulse > 0) state.dangerPulse -= dt;

    scoreEl.textContent = Math.floor(state.uiScore);
    bestEl.textContent = Math.floor(state.uiBest);
    intensityEl.textContent = state.uiIntensity.toFixed(1);
    const intensityLevel = intensityNorm();
    intensityFillEl.style.transform = `scaleX(${intensityLevel.toFixed(3)})`;
    document.body.setAttribute("data-danger", intensityLevel > 0.8 ? "1" : "0");

    const pulse = Math.max(0, state.scorePulse / POLISH.pulseTime);
    scoreEl.style.transform = `scale(${1 + pulse * POLISH.pulseScale})`;

    const danger = Math.max(0, state.dangerPulse / POLISH.pulseTime);
    intensityFillEl.style.filter = `brightness(${1 + danger * 0.6})`;
  }

  function unlockAudio(){
    if (state.audioUnlocked) return;
    state.audioUnlocked = true;
    menuMusic.volume = 0;
    gameMusic.volume = 0;
    if (!state.audioMuted){
      playMenuMusic();
    }
  }

  function crossfade(from, to, durationMs){
    if (state.audioFade) cancelAnimationFrame(state.audioFade);
    const start = performance.now();
    const fromStart = from ? from.volume : 0;
    const toTarget = to === menuMusic ? AUDIO.menuVolume : AUDIO.gameVolume;
    if (to && to.paused) to.play().catch(() => {});

    function step(now){
      const t = Math.min(1, (now - start) / durationMs);
      const eased = t * (2 - t);
      if (from){
        from.volume = fromStart * (1 - eased);
        if (t >= 1){
          from.pause();
          from.currentTime = Math.max(0, from.currentTime);
        }
      }
      if (to){
        to.volume = state.audioMuted ? 0 : toTarget * eased;
      }
      if (t < 1){
        state.audioFade = requestAnimationFrame(step);
      } else {
        state.audioFade = null;
      }
    }
    state.audioFade = requestAnimationFrame(step);
  }

  function playMenuMusic(){
    if (!state.audioUnlocked) return;
    if (menuMusic.paused){
      menuMusic.play().catch(() => {});
    }
    if (!gameMusic.paused){
      crossfade(gameMusic, menuMusic, AUDIO.crossfadeMs);
    } else {
      menuMusic.volume = state.audioMuted ? 0 : AUDIO.menuVolume;
    }
  }

  function playGameMusic(){
    if (!state.audioUnlocked) return;
    if (gameMusic.paused){
      gameMusic.play().catch(() => {});
    }
    if (!menuMusic.paused){
      crossfade(menuMusic, gameMusic, AUDIO.crossfadeMs);
    } else {
      gameMusic.volume = state.audioMuted ? 0 : AUDIO.gameVolume;
    }
  }

  function setMuted(isMuted){
    state.audioMuted = isMuted;
    localStorage.setItem("neonMuted", isMuted ? "1" : "0");
    audioToggleEl.textContent = isMuted ? "Audio Off" : "Audio On";
    if (isMuted){
      menuMusic.volume = 0;
      gameMusic.volume = 0;
    } else {
      playMenuMusic();
    }
  }

  function draw(){
    ctx.save();

    if (state.shake > 0){
      const t = state.shake;
      const power = state.shakePower * t;
      const sx = (Math.random() - 0.5) * power;
      const sy = (Math.random() - 0.5) * power;
      ctx.translate(sx, sy);
    }

    if (state.zoom > 0){
      const z = 1 + state.zoom;
      ctx.translate(w * 0.5, h * 0.5);
      ctx.scale(z, z);
      ctx.translate(-w * 0.5, -h * 0.5);
    }

    ctx.clearRect(0, 0, w, h);

    const speedFactor = 1 + intensityNorm() * POLISH.visualSpeedBoost;
    const anchorY = player.y();
    const renderY = (y) => anchorY + (y - anchorY) * speedFactor;

    // Animated background glow
    const drift = state.time * POLISH.bgDriftSpeed * speedFactor;
    const gx = w * 0.6 + Math.sin(drift * 1.3) * 120;
    const gy = h * 0.2 + Math.cos(drift * 0.9) * 90;
    const radial = ctx.createRadialGradient(gx, gy, 60, gx, gy, Math.max(w, h));
    radial.addColorStop(0, "rgba(25,247,255,0.08)");
    radial.addColorStop(0.35, "rgba(138,91,255,0.06)");
    radial.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = radial;
    ctx.fillRect(0, 0, w, h);

    // Background grid glow
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = "#1a2a44";
    for (let i = 0; i < 12; i++){
      const y = (i / 12) * h;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    const tint = intensityNorm();
    const neonR = Math.round(25 + (255 - 25) * tint);
    const neonG = Math.round(247 + (59 - 247) * tint);
    const neonB = Math.round(255 + (122 - 255) * tint);
    const neonColor = `rgb(${neonR},${neonG},${neonB})`;
    const neonGlow = `rgba(${neonR},${neonG},${neonB},0.9)`;

    // Gates
    for (const g of gates){
      const gy = renderY(g.y);
      ctx.shadowColor = `rgba(${neonR},${neonG},${neonB},0.6)`;
      ctx.shadowBlur = 10;
      ctx.fillStyle = `rgba(${neonR},${neonG},${neonB},0.18)`;
      ctx.fillRect(0, gy, g.gapX, 16);
      ctx.fillRect(g.gapX + g.gapW, gy, w, 16);

      ctx.globalAlpha = 0.15;
      ctx.fillRect(0, gy - 18, g.gapX, 18);
      ctx.fillRect(g.gapX + g.gapW, gy - 18, w, 18);
      ctx.globalAlpha = 1;

      ctx.fillStyle = neonGlow;
      ctx.fillRect(g.gapX - 2, gy - 2, 4, 20);
      ctx.fillRect(g.gapX + g.gapW - 2, gy - 2, 4, 20);
      ctx.shadowBlur = 0;
    }

    // Dash orbs telegraph + active
    for (const o of orbs){
      const oy = renderY(o.y);
      if (o.telegraphLeft > 0){
        const pulse = 0.4 + 0.6 * Math.sin((1 - o.telegraphLeft / o.telegraph) * Math.PI);
        ctx.strokeStyle = `rgba(255, 59, 122, ${0.6 * pulse})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, oy);
        ctx.lineTo(w, oy);
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.arc(o.x, oy, o.r, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 59, 122, 0.9)";
        ctx.shadowColor = "#ff3b7a";
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Player trail
    for (let i = 0; i < trail.length; i++){
      const t = trail[i];
      const alpha = (i / trail.length) * 0.35 * t.life;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 9, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${neonR},${neonG},${neonB},0.6)`;
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Player
    const py = player.y();
    ctx.beginPath();
    ctx.moveTo(player.x, py - 14);
    ctx.lineTo(player.x - 12, py + 12);
    ctx.lineTo(player.x + 12, py + 12);
    ctx.closePath();
    ctx.fillStyle = neonColor;
    ctx.shadowColor = neonColor;
    ctx.shadowBlur = 16 + Math.sin(state.time * 6) * 2;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Particles
    ctx.fillStyle = "rgba(138,91,255,0.8)";
    for (const p of particles){
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillRect(p.x, renderY(p.y), 3, 3);
    }
    ctx.globalAlpha = 1;

    if (state.flash > 0){
      ctx.globalAlpha = state.flash;
      ctx.fillStyle = "rgba(25,247,255,0.25)";
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }

    // Scanlines
    ctx.globalAlpha = POLISH.scanlineAlpha;
    ctx.fillStyle = "rgba(6,10,20,0.45)";
    for (let y = 0; y < h; y += 4){
      ctx.fillRect(0, y + (state.time * 20 * speedFactor) % 4, w, 1);
    }
    ctx.globalAlpha = 1;

    // Subtle noise
    ctx.globalAlpha = POLISH.noiseAlpha;
    ctx.fillStyle = "rgba(255,255,255,0.15)";
    for (let i = 0; i < 80; i++){
      const nx = Math.random() * w;
      const ny = Math.random() * h;
      ctx.fillRect(nx, ny, 1, 1);
    }
    ctx.globalAlpha = 1;

    // Speed lines
    const speedAlpha = POLISH.speedLineAlpha * intensityNorm();
    if (speedAlpha > 0){
      ctx.globalAlpha = speedAlpha;
      ctx.strokeStyle = "rgba(25,247,255,0.5)";
      ctx.lineWidth = 1;
      for (let i = 0; i < POLISH.speedLineCount; i++){
        const x = Math.random() * w;
        const len = 18 + Math.random() * 26 * speedFactor;
        const y = Math.random() * h;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + len);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    if (state.glitch > 0){
      const g = state.glitch;
      const ox = (Math.random() - 0.5) * 6 * g;
      const oy = (Math.random() - 0.5) * 4 * g;
      ctx.globalCompositeOperation = "screen";
      ctx.globalAlpha = 0.22 * g;
      ctx.drawImage(canvas, ox, oy);
      ctx.fillStyle = "rgba(255, 0, 80, 0.12)";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "rgba(0, 180, 255, 0.1)";
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
    }

    ctx.restore();
  }

  function loop(ts){
    const dt = Math.min(0.033, (ts - state.lastTime) / 1000 || 0);
    const timeScale = state.slowMo > 0 ? TUNING.slowMoScale : 1;
    state.lastTime = ts;

    if (state.mode === "play"){
      state.time += dt;
      const dtScaled = dt * timeScale;
      state.score += Math.floor(dtScaled * 8);
      updatePlayer(dtScaled);
      updateGates(dtScaled);
      updateOrbs(dtScaled);
      updateParticles(dtScaled);
      updateTrail(dtScaled);

      if (state.shake > 0) state.shake -= dt;
      if (state.slowMo > 0) state.slowMo -= dt;
      if (state.flash > 0) state.flash -= dt;
      if (state.glitch > 0) state.glitch -= dt;
      if (state.zoom > 0) state.zoom = Math.max(0, state.zoom - dt * 0.08);
    } else if (state.mode === "dying"){
      if (state.deathTimer > 0){
        state.deathTimer -= dt;
        if (state.deathTimer <= 0) gameOver();
      }
      if (state.freeze > 0) state.freeze -= dt;
      if (state.shake > 0) state.shake -= dt;
      if (state.flash > 0) state.flash -= dt;
      if (state.glitch > 0) state.glitch -= dt;
      if (state.zoom > 0) state.zoom = Math.max(0, state.zoom - dt * 0.06);
    }

    updateHud(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Audio
  let audioCtx = null;
  function initAudio(){
    if (!audioCtx){
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) audioCtx = new Ctx();
    }
  }
  function beep(freq, duration){
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sawtooth";
    osc.frequency.value = freq;
    gain.gain.value = 0.08;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.stop(audioCtx.currentTime + duration);
  }
  function sfxPass(){ beep(620, 0.12); }
  function sfxCrash(){ beep(180, 0.25); }

  // Monetization hook: cosmetic skins could change player color/glow here.
  // Example: swap player color based on owned cosmetics.
  function applyCosmeticSkin(){ /* integrate cosmetic system here */ }

  // Monetization hook: ads between runs.
  function showInterstitialAd(){ /* integrate ad SDK here */ }

  // Monetization hook: leaderboard submissions.
  function submitScore(score){ /* integrate leaderboard API here */ }

  // Input
  window.addEventListener("keydown", (e) => {
    unlockAudio();
    if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = true;
    if (e.code === "ArrowRight" || e.code === "KeyD") input.right = true;
    if (e.code === "KeyM"){
      setMuted(!state.audioMuted);
    }
    if (state.mode !== "play" && (e.code === "Space" || e.code === "Enter")) startGame();
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = false;
    if (e.code === "ArrowRight" || e.code === "KeyD") input.right = false;
  });

  canvas.addEventListener("pointerdown", (e) => {
    initAudio();
    unlockAudio();
    input.activePointer = true;
    player.targetX = e.clientX;
    if (state.mode !== "play") startGame();
  });
  canvas.addEventListener("pointermove", (e) => {
    if (input.activePointer) player.targetX = e.clientX;
  });
  window.addEventListener("pointerup", () => {
    input.activePointer = false;
    player.targetX = null;
  });

  startPanel.addEventListener("click", startGame);
  overPanel.addEventListener("click", startGame);
  audioToggleEl.addEventListener("click", () => {
    unlockAudio();
    setMuted(!state.audioMuted);
  });

  generateRunProfile();
  setMode("start");
  startPanel.classList.add("enter");
  setTimeout(() => startPanel.classList.remove("enter"), 600);
  bestEl.textContent = state.best;
  setMuted(localStorage.getItem("neonMuted") === "1");
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
