<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Neon Slip</title>
<style>
  :root{
    --bg: #06070b;
    --bg2: #0c1020;
    --neon: #19f7ff;
    --neon2: #8a5bff;
    --danger: #ff3b7a;
    --text: #d7f9ff;
  }
  *{ box-sizing: border-box; }
  html, body{
    margin:0; padding:0; width:100%; height:100%;
    background: radial-gradient(1200px 800px at 70% -10%, #131a33 0%, var(--bg) 45%, #05050a 100%);
    overflow:hidden; color:var(--text);
    font-family: "Trebuchet MS","Lucida Console","Courier New",monospace;
    letter-spacing: .5px;
  }
  canvas{ display:block; width:100vw; height:100vh; }
  .ui{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    pointer-events:none;
  }
  .panel{
    pointer-events:auto;
    background: linear-gradient(180deg, rgba(15,20,40,.9), rgba(6,10,20,.9));
    border:1px solid rgba(25,247,255,.35);
    box-shadow: 0 0 25px rgba(25,247,255,.2), inset 0 0 30px rgba(138,91,255,.15);
    padding:24px 28px; border-radius:14px; text-align:center; max-width:320px;
  }
  .title{
    font-size:28px; color:var(--neon); text-transform:uppercase;
    text-shadow: 0 0 12px rgba(25,247,255,.8);
    margin-bottom:8px;
  }
  .btn{
    margin-top:16px; display:inline-block; padding:10px 18px;
    border:1px solid rgba(25,247,255,.5);
    background: rgba(25,247,255,.1);
    color:var(--text); border-radius:10px; cursor:pointer;
  }
  .hint{ font-size:12px; opacity:.8; margin-top:8px; }
  .hidden{ display:none; }
  .hud{
    position:fixed; inset:0; pointer-events:none; padding:14px;
    display:flex; justify-content:space-between; font-size:14px;
    text-shadow: 0 0 8px rgba(25,247,255,.4);
  }
  .badge{
    background: rgba(10,14,26,.6);
    border:1px solid rgba(25,247,255,.25);
    padding:6px 10px; border-radius:10px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="hud">
  <div class="badge">Score: <span id="score">0</span></div>
  <div class="badge">Best: <span id="best">0</span></div>
</div>

<div class="ui">
  <div id="startPanel" class="panel">
    <div class="title">Neon Slip</div>
    <div>Move left/right to slip through the neon gates.</div>
    <div class="hint">Keys: A/D or Arrows. Touch: drag or tap.</div>
    <div class="btn">Tap to Start</div>
  </div>
  <div id="overPanel" class="panel hidden">
    <div class="title">Crashed</div>
    <div>Score: <span id="finalScore">0</span></div>
    <div>Best: <span id="finalBest">0</span></div>
    <div class="btn">Try Again</div>
    <div class="hint">Instant restart keeps the flow.</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const bestEl = document.getElementById("best");
  const startPanel = document.getElementById("startPanel");
  const overPanel = document.getElementById("overPanel");
  const finalScoreEl = document.getElementById("finalScore");
  const finalBestEl = document.getElementById("finalBest");

  let w, h, dpr;
  function resize(){
    dpr = Math.max(1, window.devicePixelRatio || 1);
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  const state = {
    mode: "start",
    time: 0,
    score: 0,
    best: +localStorage.getItem("neonBest") || 0,
    shake: 0,
    shakePower: 0,
    lastTime: 0
  };

  const player = {
    x: w * 0.5,
    y: () => h * 0.82,
    r: 10,
    speed: 520,
    targetX: null
  };

  const input = { left:false, right:false, activePointer:false };

  const gates = [];
  const particles = [];

  function resetGame(){
    state.time = 0;
    state.score = 0;
    gates.length = 0;
    particles.length = 0;
    player.x = w * 0.5;
    player.targetX = null;
    state.shake = 0;
    state.shakePower = 0;
    spawnGate(-80, true);
  }

  function startGame(){
    initAudio();
    resetGame();
    state.mode = "play";
    startPanel.classList.add("hidden");
    overPanel.classList.add("hidden");
  }

  function gameOver(){
    state.mode = "over";
    if (state.score > state.best){
      state.best = state.score;
      localStorage.setItem("neonBest", state.best);
    }
    finalScoreEl.textContent = state.score;
    finalBestEl.textContent = state.best;
    scoreEl.textContent = state.score;
    bestEl.textContent = state.best;

    // Monetization hook: show interstitial ad between runs here.
    showInterstitialAd();

    // Leaderboard hook: submit score to server here.
    submitScore(state.score);

    overPanel.classList.remove("hidden");
  }

  function spawnGate(yOverride, easy){
    const difficulty = Math.min(1, state.time / 45);
    const gapW = Math.max(80, 180 - difficulty * 90);
    const speed = 180 + difficulty * 240;
    const gapX = 40 + Math.random() * (w - 80 - gapW);
    gates.push({
      y: yOverride != null ? yOverride : -40,
      gapX, gapW, speed, passed:false
    });
  }

  function updateGates(dt){
    const difficulty = Math.min(1, state.time / 45);
    const interval = 1.15 - difficulty * 0.55;
    state.spawnTimer = (state.spawnTimer || 0) - dt;
    if (state.spawnTimer <= 0){
      spawnGate();
      state.spawnTimer = interval;
    }

    for (let i = gates.length - 1; i >= 0; i--){
      const g = gates[i];
      g.y += g.speed * dt;

      if (!g.passed && g.y > player.y()){
        g.passed = true;
        const px = player.x;
        const inside = px > g.gapX && px < g.gapX + g.gapW;
        if (!inside){
          sfxCrash();
          state.shake = 0.35;
          state.shakePower = 12;
          gameOver();
          return;
        } else {
          const edgeDist = Math.min(
            Math.abs(px - g.gapX),
            Math.abs(px - (g.gapX + g.gapW))
          );
          const bonus = edgeDist < 18 ? 8 : edgeDist < 35 ? 4 : 2;
          state.score += 10 + bonus;
          sfxPass();
          spawnParticles(px, g.y);
          state.shake = 0.12;
          state.shakePower = 5;
        }
      }

      if (g.y > h + 60) gates.splice(i, 1);
    }
  }

  function updatePlayer(dt){
    const move = (input.right ? 1 : 0) - (input.left ? 1 : 0);
    if (player.targetX != null){
      const dx = player.targetX - player.x;
      const step = Math.sign(dx) * player.speed * dt;
      if (Math.abs(step) > Math.abs(dx)) player.x = player.targetX;
      else player.x += step;
    } else if (move !== 0){
      player.x += move * player.speed * dt;
    }
    player.x = Math.max(14, Math.min(w - 14, player.x));
  }

  function spawnParticles(x, y){
    for (let i = 0; i < 10; i++){
      particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 160,
        vy: -Math.random() * 120,
        life: 0.5 + Math.random() * 0.3
      });
    }
  }

  function updateParticles(dt){
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 220 * dt;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function draw(){
    ctx.save();

    if (state.shake > 0){
      const t = state.shake;
      const power = state.shakePower * t;
      const sx = (Math.random() - 0.5) * power;
      const sy = (Math.random() - 0.5) * power;
      ctx.translate(sx, sy);
    }

    ctx.clearRect(0, 0, w, h);

    // Background grid glow
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = "#1a2a44";
    for (let i = 0; i < 12; i++){
      const y = (i / 12) * h;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Gates
    for (const g of gates){
      ctx.fillStyle = "rgba(25,247,255,0.2)";
      ctx.fillRect(0, g.y, g.gapX, 16);
      ctx.fillRect(g.gapX + g.gapW, g.y, w, 16);

      ctx.fillStyle = "rgba(25,247,255,0.9)";
      ctx.fillRect(g.gapX - 2, g.y - 2, 4, 20);
      ctx.fillRect(g.gapX + g.gapW - 2, g.y - 2, 4, 20);
    }

    // Player
    const py = player.y();
    ctx.beginPath();
    ctx.moveTo(player.x, py - 14);
    ctx.lineTo(player.x - 12, py + 12);
    ctx.lineTo(player.x + 12, py + 12);
    ctx.closePath();
    ctx.fillStyle = "#19f7ff";
    ctx.shadowColor = "#19f7ff";
    ctx.shadowBlur = 14;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Particles
    ctx.fillStyle = "rgba(138,91,255,0.8)";
    for (const p of particles){
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillRect(p.x, p.y, 3, 3);
    }
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function loop(ts){
    const dt = Math.min(0.033, (ts - state.lastTime) / 1000 || 0);
    state.lastTime = ts;

    if (state.mode === "play"){
      state.time += dt;
      state.score += Math.floor(dt * 6);
      updatePlayer(dt);
      updateGates(dt);
      updateParticles(dt);

      if (state.shake > 0) state.shake -= dt;

      scoreEl.textContent = state.score;
      bestEl.textContent = state.best;
    }

    draw();
    requestAnimationFrame(loop);
  }

  // Audio
  let audioCtx = null;
  function initAudio(){
    if (!audioCtx){
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) audioCtx = new Ctx();
    }
  }
  function beep(freq, duration){
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sawtooth";
    osc.frequency.value = freq;
    gain.gain.value = 0.08;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.stop(audioCtx.currentTime + duration);
  }
  function sfxPass(){ beep(620, 0.12); }
  function sfxCrash(){ beep(180, 0.25); }

  // Monetization hook: cosmetic skins could change player color/glow here.
  // Example: swap player color based on owned cosmetics.
  function applyCosmeticSkin(){ /* integrate cosmetic system here */ }

  // Monetization hook: ads between runs.
  function showInterstitialAd(){ /* integrate ad SDK here */ }

  // Monetization hook: leaderboard submissions.
  function submitScore(score){ /* integrate leaderboard API here */ }

  // Input
  window.addEventListener("keydown", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = true;
    if (e.code === "ArrowRight" || e.code === "KeyD") input.right = true;
    if (state.mode !== "play" && (e.code === "Space" || e.code === "Enter")) startGame();
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = false;
    if (e.code === "ArrowRight" || e.code === "KeyD") input.right = false;
  });

  canvas.addEventListener("pointerdown", (e) => {
    initAudio();
    input.activePointer = true;
    player.targetX = e.clientX;
    if (state.mode !== "play") startGame();
  });
  canvas.addEventListener("pointermove", (e) => {
    if (input.activePointer) player.targetX = e.clientX;
  });
  window.addEventListener("pointerup", () => {
    input.activePointer = false;
    player.targetX = null;
  });

  startPanel.addEventListener("click", startGame);
  overPanel.addEventListener("click", startGame);

  bestEl.textContent = state.best;
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
